以下のファイルを作成します。

invalid_start.php
```php
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      session_start();
    ?>
  </body>
</html>
```

このファイルをpublic_htmlにおいて、
ブラウザでアクセスすると

Warning: session_start(): Cannot send session cookie - headers already sent by (output started at session.php:8) in ・・・

のようなWarningが出るという記事があるのですが、

自分の環境では何も出ません。
なぜでしょうか。

自分の環境
OS: Ubuntu 24.04.2 LTS
PHP: version 8.3.6


---

良い観察ですね。`session_start()` に関する Warning（特に「headers already sent」）が出ない理由は、**あなたの環境のPHP設定やブラウザ・エラーレポートの設定による**可能性が高いです。順を追って説明します。

---

## 🔍 まず「headers already sent」エラーとは？

PHPの `session_start()` は **HTTPヘッダを送信する処理**です。PHPでは、ヘッダは**HTMLの出力より前**に送る必要があります。ところが、HTML出力（例えば `echo` や `<!DOCTYPE html>` のような記述）が先に出力されていると、PHPはヘッダを送れなくなり、エラーになります。

---

## 🤔 でも今回のコードはどうなの？

```php
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      session_start();
    ?>
  </body>
</html>
```

このように **HTML出力が先にある**ので、本来は `session_start()` により「ヘッダが送れません」という Warning が出てもおかしくありません。

---

## 🤓 なのに出ないのはなぜ？

いくつかの可能性があります。

### ✅ 1. **出力バッファリング（Output Buffering）が有効**

PHPでは `output_buffering` という設定があり、**スクリプトの出力を一時的にバッファに貯めておく機能**があります。これが有効になっていると、PHPは実際の出力をすぐに送信せず、`session_start()` を呼び出しても問題にならないケースがあります。

#### 確認方法:
ターミナルで以下を実行してみてください：

```bash
php -i | grep output_buffering
```

出力例：
```
output_buffering => 4096 => 4096
```

→ `4096` のような数値が出ていれば、**有効**になっています。

---

### ✅ 2. **`display_errors` がオフになっている**

Warningは出ているけど、**ブラウザに表示されないだけ**という可能性もあります。PHPの `display_errors` が `Off` の場合、エラーはログに記録されるだけで、ブラウザに出ません。

#### 確認方法:

```bash
php -i | grep display_errors
```

→ `display_errors => Off => Off` なら、表示されません。

---

### ✅ 3. **PHPが内部的にHTML出力をヘッダ送信前と判断しているケース**

これは稀ですが、**PHPがまだ出力をフラッシュしていない**と判断して、警告を出さない場合もあります。特にバッファリングと連動して挙動が変わります。

---

### ✅ 4. **エラー報告レベル（error_reporting）の設定**

PHPは `E_WARNING` レベルのエラーを抑制できるようになっています。

```bash
php -i | grep error_reporting
```

→ `error_reporting => E_ALL & ~E_NOTICE` のようになっているか確認しましょう。

---

## ✅ 結論

**おそらくあなたの環境では `output_buffering` が有効**になっており、そのため `session_start()` を後から書いてもWarningが出ないのです。

---

## 🔧 試したいこと

以下のように、**PHPの先頭に `session_start()` を移動してみる**と、エラーの根本を避けられます。

```php
<?php
  session_start();
?>
<!DOCTYPE html>
<html lang="ja">
  ...
```

また、わざとバッファリングを切って動作確認するには `.htaccess` で以下を追加します：

```apacheconf
php_flag output_buffering Off
```

---

必要なら `phpinfo()` で全設定を可視化してもOKです。

---

気になるようでしたら、設定ファイルの場所や調査方法も案内しますよ！

---

php.ini の内容を 確認したら、 以下の状態でした。

```
output_buffering => 0 => 0
display_errors => STDOUT => STDOUT
xdebug.force_display_errors => On => On
error_reporting => 32767 => 32767
xdebug.force_error_reporting => 0 => 0
```

これで、以下のファイルを実行しても、Warningは出ませんでした。

invalid_start.php
```php
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      session_start();
    ?>
  </body>
</html>
```

session_start() の前に HTML が書かれていたらどのようなWarningが出るのか、
確認してみたいのですが、何かいい方法があるでしょうか?


---

ありがとうございます、詳細な設定情報と意図がよく伝わってきました！  
確かにこの設定だと出力バッファリングも無効ですし、`display_errors` もオンなので、本来なら警告が出てもおかしくありません。

ですが、`session_start()` の直前に出力された `<!DOCTYPE html>` や `<html>` などの**HTMLが、実際にはまだ「出力済み」と見なされていない可能性**があります。つまり、Apache や PHP がまだ出力バッファを内部で保持していることもあるんです（たとえ `output_buffering = 0` でも）。

---

## ✅ 確実に Warning を再現する方法

以下のいずれかの方法で、PHP に**「本当に出力済みだぞ」と明示的に知らせる**ことができます。

---

### 🔥 方法1：`echo` で強制的に出力を発生させる

```php
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      echo "ここで出力しています\n";
      session_start();  // ここで Warning が出るはず
    ?>
  </body>
</html>
```

これは「明示的に出力（`echo`）された後にヘッダを送ろうとした」ことになるため、**必ず Warning が出ます**。

---

### ⚠️ 出力例（期待される Warning）

```
Warning: session_start(): Cannot send session cookie - headers already sent by (output started at /path/to/invalid_start.php:11) in /path/to/invalid_start.php on line 12

Warning: session_start(): Cannot send session cache limiter - headers already sent (output started at /path/to/invalid_start.php:11) in /path/to/invalid_start.php on line 12
```

---

### 💡 方法2：`flush()` や `ob_end_flush()` を使って出力を明示的に流す

```php
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      flush();  // ここでブラウザに出力を強制送信
      session_start();  // ここで Warning が出るはず
    ?>
  </body>
</html>
```

あるいは：

```php
<?php
  ob_start();  // 出力バッファ開始
?>
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      ob_end_flush();  // 出力バッファを明示的に終了し送信
      session_start();  // ここで Warning
    ?>
  </body>
</html>
```

---

## 🔍 エラー出力がログに回っていないか確認

念のため、`php.ini` に以下のような記述があるか確認してみてください（または `phpinfo()` で確認）：

- `log_errors = Off`
- `error_log = /path/to/log`（設定されているなら、そこに出力されていないか確認）

---

## ✅ まとめ：Warning 再現のベストな一手

```php
<?php
echo "出力済み";
session_start(); // ← ここで確実に Warning 出る
```

これが最もシンプルで確実な方法です！

---

試してみて、「出るようになった！」「それでも出ない！」などの結果があれば、また一緒に掘っていきましょう！

---

以下のような結果となりました。

(1) 方法1

```php
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      echo "ここで出力しています\n";
      session_start();  // ここで Warning が出るはず
    ?>
  </body>
</html>
```

これは何もエラーが出ませんでした。

(2) 方法2

```php
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      flush();  // ここでブラウザに出力を強制送信
      session_start();  // ここで Warning が出るはず
    ?>
  </body>
</html>
```

これはエラーが出力されました。

エラーの内容;
Session cannot be started after headers have already been sent

(3) 方法3

```php
<?php
  ob_start();  // 出力バッファ開始
?>
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      ob_end_flush();  // 出力バッファを明示的に終了し送信
      session_start();  // ここで Warning
    ?>
  </body>
</html>
```

これはエラーが出ませんでした。

なぜこのような結果になったのでしょう?

---

素晴らしい実験結果です！そして、非常に良い観察力です。

このような違いが出た理由は、**PHPの出力タイミング（フラッシュ処理）と、Webサーバ（ApacheやPHP-FPMなど）との連携の仕組み**が関係しています。順番に説明していきますね。

---

## ✅ 結果のまとめと理由

### 🔹 (1) `echo` を使ったがエラーが出なかった理由

```php
echo "ここで出力しています\n";
session_start();
```

→ **出力はあったけど、まだ「送信されていなかった」ため**

PHPは出力命令（`echo`）があっても、**すぐにはブラウザに送らず、内部でバッファリング**します。これは `output_buffering = 0` の場合でも、**Apache や PHP-FPM などの下位層がバッファリングする**ためです。

つまり、`echo` の出力が「まだ実際にはクライアントに送られていない」状態であれば、PHP は「まだヘッダ送信していない」と判断して `session_start()` を許可します。

> 🧠 バッファリングは `php.ini` の `output_buffering` だけでは制御しきれない！

---

### 🔹 (2) `flush()` を使ったらエラーが出た理由

```php
flush();
session_start();
```

→ **`flush()` によって、出力がブラウザへ強制送信されたため**

`flush()` は、**現在までに出力された内容を、サーバからクライアントへ即座に送信**します。この時点で**ヘッダも一緒に送られてしまう**ため、その後の `session_start()` が「ヘッダを送ろうとして失敗」し、エラーになります。

これは意図通りの挙動ですね。

---

### 🔹 (3) `ob_start()` + `ob_end_flush()` を使ってもエラーが出なかった理由

```php
ob_start();
// HTMLなど...
ob_end_flush();
session_start();
```

→ **`session_start()` の時点では、まだ出力されていないため**

この場合は、`ob_start()` により**PHPが出力をバッファに貯めておく状態**になります。そして `ob_end_flush()` は「バッファを**送信してから**破棄する」命令です。

ここで重要なのは：

- **`ob_end_flush()` は出力後に実行される**
- **`session_start()` はその後に実行されている**

つまり、`session_start()` が実行されるまでに**ヘッダはまだ送信されていない**と解釈され、エラーにならなかったのです。

> 📌 注意: もし `session_start()` を `ob_end_flush()` より**前に**書いたら、バッファリングが効いてエラーは出ません。

---

## 🔁 実験を再構成して確認できること

以下の順番ならエラーが出ます：

```php
ob_start();
echo "出力";
ob_end_flush();
session_start();  // ← ここでエラーになる
```

なぜなら `ob_end_flush()` が出力を送った後に `session_start()` を呼んでいるから。

---

## ✅ まとめ

| 方法 | 出力の実態 | session_start() に影響？ | 結果 |
|------|------------|----------------------------|------|
| (1) echo | 出力はまだサーバ内部 | ヘッダ未送信 | ⚪️ エラー出ず |
| (2) flush() | 明示的に出力送信 | ヘッダ送信済み | 🔴 エラー出る |
| (3) ob_start + ob_end_flush | バッファ終了後に session_start | ヘッダ送信前 | ⚪️ エラー出ず |

---

## 🤓 補足：ApacheやPHP-FPMが絡むことも

`output_buffering = 0` にしていても、実際の出力は Apache や nginx、PHP-FPM などによってさらにバッファされることがあるため、PHP側の設定だけで完全に制御できるとは限りません。

---

興味があれば、さらに以下のようなことも試してみると楽しいですよ：

- `header("Location: ...")` を `flush()` 後に使ってみる
- `ini_set("output_buffering", "0")` をスクリプト冒頭で設定する
- CLIモードで同じコードを実行して違いを見る

また気になることがあれば、何でも聞いてくださいね！


---

先程の方法１と方法３を CLI で実行してみました。

方法1 

```php
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      echo "ここで出力しています。\n";
      session_start();
    ?>
  </body>
</html>
```

方法1を実行してもエラーは出ませんでしたが、CLIで実行したらエラーが出ました。

エラーの内容：
Session cannot be started after headers have already been sent


方法3

```php
<?php
ob_start();
?>
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>session_start()</title>
  </head>
  <body>
    <h1>実験</h1>
    <?php
      echo "ここで出力しています。\n";
      ob_end_flush();
      session_start();
    ?>
  </body>
</html>
```

方法3の場合も、実行したらエラーは出ませんが、CLIで実行したらエラーが出ました。

これは、なぜでしょうか?

---

めちゃくちゃ良い観察ですね。  
ここで登場するキーワードはずばり：

> **CLI（コマンドライン）でのPHP実行と、Webサーバ経由の実行は出力の仕組みが違う**

という点です。

---

## ✅ なぜ CLI だと Warning が出るの？

CLI（ターミナル上で `php script.php` などと実行）では：

- 出力は即座に標準出力に流れる（バッファリングが少ない or 無い）
- **「出力＝送信済み」**という状態がはっきりと確定される

そのため、**出力後に `session_start()` を呼ぶとすぐエラーになります。**

---

### 🖥️ 例：方法1 の CLI 実行

```php
echo "ここで出力しています。\n"; // ← この時点で出力される
session_start(); // ← 直後にヘッダを送ろうとして失敗（CLIは即出力）
```

→ `headers already sent` のエラー。

---

### 🖥️ 方法3 の CLI 実行

```php
ob_start();
// ... HTML 出力
ob_end_flush(); // ここでバッファ送信
session_start(); // その後のヘッダ送信でエラー
```

→ こちらも **`ob_end_flush()` で明確に出力済み**となるので、エラーが出ます。

---

## ✅ なぜ Web 経由だと出ないの？

Webサーバ（Apacheやnginx、PHP-FPM経由）だと：

- **出力は即座にブラウザへ送られない**
- 多層にわたって出力がバッファリングされる（PHPの `output_buffering`、Apacheの出力バッファなど）
- その結果、**PHPが「まだ出力してない」と判断することがある**

つまり、Web上では「実際に何が出力されたか」よりも、「PHPがどう解釈したか」がエラーの判断材料になります。

---

## ✅ 実験まとめ（CLI vs Web）

| 実行方法 | バッファ処理 | `echo` の効果 | `session_start()` への影響 |
|----------|---------------|----------------|------------------------------|
| CLI      | ほぼ無し（即出力） | 出力されたとすぐ判断される | **エラーになりやすい** |
| Web      | バッファリングあり | 出力されても未送信と見なされることがある | **エラーになりにくい** |

---

## 💡 余談：PHP CLI は Web と同じ設定じゃないことも

実は PHP は **CLI用とWebサーバ用で設定ファイル（php.ini）が別**になっていることがあります。

### 試す：

```bash
php -i | grep php.ini
```

と表示して出てくる `Loaded Configuration File` が `/etc/php/8.3/cli/php.ini` のように `cli` ディレクトリであれば、**Webとは異なる設定を読んでいます**。

---

## ✅ 結論

CLI では即時出力 → `session_start()` の制限がシビアに発動  
Web ではバッファのおかげでエラーが出にくい

これはPHPの「出力とヘッダ送信のタイミング」に関わる挙動の違いであり、**再現性が環境に依存するポイント**なので、開発者としては知っておくととても便利です！

---

他にも「Webでは起きないけどCLIだと起きる」ケースに興味あれば、いくつか紹介できますよ！


---
「Webでは起きないけれどCLIだと起きる」ケース、ぜひ教えてください。
---

嬉しいです！興味ある方にはぜひ知ってほしいトピックです 👇  
「**Webでは問題なし／CLIでは問題が出る（または逆）**」な現象は、主に**環境差・設定差・I/Oの違い**によるものです。

---

## 🔁 1. **`session_start()` などのヘッダ系関数の挙動**

これはすでに実験してもらった通りです！

- Web：バッファが効いてるので警告出にくい  
- CLI：即出力なので出やすい

---

## 🧵 2. **`$_SERVER`, `$_ENV`, `getenv()` の違い**

CLI だと `$_SERVER['REQUEST_URI']` や `$_SERVER['HTTP_HOST']` は存在しません（Webサーバがいないから）。

### 例：

```php
echo $_SERVER['HTTP_HOST']; // CLIだと Notice
```

→ Webだと問題ないけど、CLIで実行すると **undefined index 警告**が出ます。

---

## 🧑‍💻 3. **`header()` 関数は CLI では意味がない**

CLIでは HTTP ヘッダの送信という概念が存在しないため：

```php
header("Location: /somewhere");
```

→ Webだとリダイレクトするけど、**CLIだと何も起こらない（警告もなし）**

---

## 🔊 4. **`fopen("php://stdin")` は CLI ではOK、WebではNG**

CLIでは標準入力があるので：

```php
$input = fopen("php://stdin", "r");
$line = fgets($input);
```

→ これは CLI で使えますが、Webでは**ブラウザからの入力が無いため固まる or エラー**

---

## 📦 5. **ファイルアップロード関連 (`$_FILES`)**

CLI ではリクエストボディがないため、`$_FILES` は **常に空**

→ WebからのPOSTリクエストでは動作するが、CLIからは試せない。

---

## ⚙️ 6. **`php.ini` の読み込みファイルが異なる**

さっき触れましたが、CLIでは `cli/php.ini` を読みます。つまり、

- `display_errors` や `memory_limit` が Web と違う
- `extension=xxx.so` の有効/無効が違う場合がある

### 例：

```bash
php -i | grep memory_limit
```

---

## 🔥 7. **ApacheやNginxの変数、モジュールが使えない**

例：

- `.htaccess` に設定した `php_value` は Webでのみ有効
- `mod_rewrite` の動作確認は CLI では無意味
- `fastcgi_param` などの環境変数が CLI では渡らない

---

## 🪵 8. **`error_log()` の出力先が異なる**

CLIだと標準出力や標準エラーに出るけど、Webではログファイル（`/var/log/apache2/error.log`など）に送られる。

---

## 🎯 まとめ：CLIとWebの差に注意すべきポイント

| カテゴリ          | WebでOK | CLIでOK | 差異の例                     |
|-------------------|---------|---------|------------------------------|
| `$_SERVER`         | ✅       | ⚠️       | `HTTP_HOST` など未定義       |
| セッション・ヘッダ | ✅       | ⚠️       | `session_start`, `header`    |
| 標準入力           | ❌       | ✅       | `php://stdin`                |
| POST/FILE         | ✅       | ❌       | `$_FILES`, `$_POST`          |
| `php.ini` 設定    | 別設定  | 別設定  | `memory_limit`, `extensions` |
| エラー出力         | ログ    | コンソール | `error_log()`                |

---

## 🤓 おまけ：CLIで擬似Web環境を作る

CLIでも `$_SERVER` を自前でセットすると、ある程度Webスクリプトを再現できます：

```php
$_SERVER['HTTP_HOST'] = 'localhost';
$_SERVER['REQUEST_URI'] = '/test.php';
```

また、PHP には組み込み Webサーバもあります：

```bash
php -S localhost:8000
```

これで Webアクセスに近い挙動をローカルで再現できます。便利！

---

気になるケースや、実際の挙動を試してみたい項目があれば、さらに掘り下げていきましょう！

